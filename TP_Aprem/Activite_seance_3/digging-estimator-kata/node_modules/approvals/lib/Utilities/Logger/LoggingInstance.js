"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggingInstance = void 0;
const StringWrapper_1 = require("./StringWrapper");
class Toggles {
    constructor(show) {
        this.queries = show;
        this.messages = show;
        this.variables = show;
        this.hourglass = show;
        this.markers = show;
        this.events = show;
    }
}
function printType(value) {
    return `<${value.constructor.name}>`;
}
function getCallingMethod(additional_stack) {
    var _a;
    const re = /at ([^(]+) \(/g;
    const stack = `${new Error().stack}`;
    const lines = stack.split("\n");
    const stackDepth = 2 + additional_stack;
    const line = lines[stackDepth];
    const aRegexResult = (_a = re.exec(line)) !== null && _a !== void 0 ? _a : [];
    const name = aRegexResult[1] || aRegexResult[2];
    return name;
}
class LoggingInstance {
    constructor() {
        this.counter = 0;
        this.tabs = 0;
        this.toggles = new Toggles(true);
        this.logStackTraces = true;
        this.logWithTimestamps = true;
        this.previousTimestamp = null;
        this.logger = (s) => process.stdout.write(s);
        this.timer = () => new Date();
    }
    logToString() {
        const stringWrapper = new StringWrapper_1.StringWrapper();
        this.logWithTimestamps = false;
        this.logStackTraces = false;
        this.logger = (t) => stringWrapper.append(t);
        return stringWrapper;
    }
    useMarkers(additional_stack, code, parameters = "", logReturnValue = false) {
        if (!this.toggles.markers) {
            return code();
        }
        const name = getCallingMethod(additional_stack + 1);
        let parameterText = "";
        if (typeof parameters === 'function') {
            parameterText = parameters();
        }
        else {
            parameterText = parameters;
        }
        this.logLine(`=> ${name}(${parameterText})`);
        const returnValue = this.withTabbing(code);
        if (typeof parameters === 'function') {
            parameterText = parameters();
        }
        else {
            parameterText = "";
        }
        let returnText = "";
        if (logReturnValue) {
            returnText = `: ${returnValue}`;
        }
        this.logLine(`<= ${name}(${parameterText})${returnText}`);
        return returnValue;
    }
    variable(name, value, showTypes) {
        if (!this.toggles.variables) {
            return;
        }
        let toType = (v, s = "") => '';
        if (showTypes) {
            toType = (value, spacing = " ") => `${spacing}${printType(value)}`;
        }
        if (Array.isArray(value)) {
            this.logLine(`variable: ${name}${toType(value, '')}.length = ${value.length}`);
            this.withTabbing(() => {
                value.forEach((v, i) => {
                    this.logger(`${this.getTabs()}${name}[${i}] = ${v}${toType(v)}\n`);
                });
            });
        }
        else {
            this.logLine(`variable: ${name} = ${value}${toType(value)}`);
        }
    }
    logLine(text, use_timestamps = true) {
        if (this.counter != 0) {
            this.logger("\n");
        }
        this.counter = 0;
        const timestamp = use_timestamps ? this.getTimestamp() : "";
        const output_message = `${timestamp}${this.getTabs()}${text}\n`;
        this.logger(output_message);
    }
    getTabs() {
        return "  ".repeat(this.tabs);
    }
    withTabbing(code) {
        this.tabs += 1;
        const returnValue = code();
        this.tabs -= 1;
        return returnValue;
    }
    hourglass() {
        if (!this.toggles.hourglass) {
            return;
        }
        this.counter += 1;
        if (this.counter == 1) {
            this.logger(`${this.getTabs()}.`);
        }
        else if (this.counter == 100) {
            this.logger("10\n");
            this.counter = 0;
        }
        else if (this.counter % 10 == 0) {
            const digit = (this.counter / 10);
            this.logger(`${digit}`);
        }
        else {
            this.logger(".");
        }
    }
    showAll(show) {
        this.toggles = new Toggles(show);
    }
    event(event_name) {
        if (!this.toggles.events) {
            return;
        }
        this.logLine(`event: ${event_name}`);
    }
    showQueries(show) {
        this.toggles.queries = show;
    }
    showMarkers(show) {
        this.toggles.markers = show;
    }
    showEvents(show) {
        this.toggles.events = show;
    }
    showMessages(show) {
        this.toggles.messages = show;
    }
    showVariables(show) {
        this.toggles.variables = show;
    }
    showHourglass(show) {
        this.toggles.hourglass = show;
    }
    warning(exception) {
        const warning_stars = "*".repeat(91);
        const text = null;
        this.logLine(warning_stars, false);
        if (this.logWithTimestamps) {
            this.logLine("", true);
        }
        if (text) {
            this.logLine(`Message:${text}`, false);
        }
        if (exception) {
            let stack_trace = "";
            if (this.logStackTraces) {
                // todo: grab stack trace
                stack_trace = exception.toString();
            }
            else {
                stack_trace = `${exception}`;
            }
            this.logLine(stack_trace, false);
        }
        this.logLine(warning_stars, false);
    }
    query(queryText) {
        if (!this.toggles.queries) {
            return;
        }
        this.logLine(`Sql: ${queryText}`);
    }
    message(messageText) {
        if (!this.toggles.messages) {
            return;
        }
        this.logLine(`message: ${messageText}`);
    }
    showTimestamps(show) {
        this.logWithTimestamps = show;
    }
    getTimestamp() {
        if (!this.logWithTimestamps) {
            return "";
        }
        const time1 = this.timer();
        const time = time1.toISOString();
        let diff_millseconds = 0;
        if (this.previousTimestamp != null) {
            diff_millseconds = time1.getTime() - this.previousTimestamp.getTime();
        }
        const diff_display = `~${String(diff_millseconds).padStart(6, "0")}ms`;
        let time_text = `${time}`.replace("T", " ").substring(0, 19);
        const timestamp = `[${time_text} ${diff_display}] `;
        this.previousTimestamp = time1;
        return timestamp;
    }
}
exports.LoggingInstance = LoggingInstance;
